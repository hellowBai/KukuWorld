# PetCollector 项目设计原则

## 1. 模块化设计原则
- **功能分离**：将游戏功能按职责划分为不同的模块（数据、系统、控制器、UI）
- **低耦合高内聚**：每个模块专注于单一职责，模块间依赖关系清晰
- **易于扩展**：新功能可以方便地添加到相应模块中
- **目录结构**：Src目录下的子目录分别对应不同功能域（Core, Data, Gameplay, Systems, UI, Utils）

## 2. 数据驱动设计
- **数据结构先行**：先定义清晰的数据结构，再实现相应功能
- **统一数据访问**：通过专门的数据类管理游戏数据
- **数据验证**：对输入和输出数据进行验证，确保数据一致性
- **基类设计**：PetData作为基础类，MythicalPetData继承自PetData，UnitData和HeroData作为独立的单位类型

## 3. 阶段化游戏流程
- **明确阶段划分**：捕捉阶段和防守阶段有明确的边界和转换条件
- **状态管理**：通过GameManager的状态机管理游戏的不同阶段
- **时间约束**：捕捉阶段有明确的时间限制，增加游戏节奏感
- **阶段切换**：CaptureSystem和BattleSystem分别处理不同阶段的逻辑

## 4. 继承与多态原则
- **继承体系**：MythicalPetData继承PetData，体现类型层次
- **多态实现**：通过重写方法实现不同类型对象的差异化行为
- **接口统一**：提供统一的接口供其他系统调用
- **类型区分**：UnitData、HeroData、PetData、MythicalPetData有不同的属性和行为

## 5. 事件驱动架构
- **松耦合通信**：系统间通过事件进行通信，降低依赖关系
- **响应式设计**：系统能够响应各种游戏事件并做出相应处理
- **可扩展性**：新的监听者可以轻松加入事件系统
- **生命周期**：各系统有明确的初始化和清理流程

## 6. 渐进式复杂度
- **简单起步**：从基础功能开始，逐步增加复杂特性
- **迭代开发**：每个版本都建立在稳定的基础上
- **平衡性考虑**：在增加复杂度的同时保持游戏平衡
- **进阶系统**：捕捉→进化→融合→装备，形成渐进的游戏深度

## 7. 用户体验优先
- **直观操作**：游戏机制设计直观易懂
- **及时反馈**：给玩家及时的操作反馈
- **进度感知**：让玩家清楚自己的进展和目标
- **视觉表现**：通过颜色、特效等方式增强游戏体验

## 8. 可维护性原则
- **代码清晰**：良好的命名规范和注释
- **结构化组织**：合理的目录结构和文件组织
- **文档完备**：完善的设计文档和API说明
- **命名一致**：命名规范保持一致（如RarityType, EvolutionStage等枚举类型）

## 9. 性能考虑
- **资源管理**：合理管理游戏资源，避免内存泄漏
- **对象池**：对频繁创建销毁的对象使用对象池
- **优化时机**：在不影响开发效率的前提下考虑性能优化
- **内存控制**：避免不必要的对象创建和引用循环

## 10. 可测试性
- **单元测试友好**：设计便于单元测试的代码结构
- **模拟对象**：为依赖项提供模拟实现
- **功能独立**：确保各功能模块可以独立测试
- **接口抽象**：使用接口抽象降低模块间耦合度

## 11. 游戏机制设计原则
- **捕捉机制**：前5分钟捕捉野怪，野怪死亡后掉落灵魂、金钱、宠物蛋
- **进化机制**：宠物通过吸收野怪灵魂进化，提升稀有度和属性
- **融合机制**：进化到最终等级的宠物可与特定机器人融合
- **装备机制**：融合后的终极单位可装备六件装备
- **防守机制**：使用捕捉到的宠物和建造的防御设施抵御敌人
- **经济系统**：金币、神石、灵魂等多资源系统平衡

## 12. 系统交互原则
- **单一职责**：每个系统只负责特定的功能领域
- **依赖注入**：通过接口或构造函数注入依赖，而非硬编码
- **数据流清晰**：数据流向明确，避免循环依赖
- **事件解耦**：系统间通过事件通信，降低耦合度
- **中心化管理**：GameManager作为中央协调器管理各子系统

## 13. 数据持久化原则
- **存档系统**：PlayerData管理玩家的所有数据
- **序列化支持**：数据类支持JSON或其他格式的序列化
- **增量保存**：避免频繁全量保存，提高性能
- **备份机制**：关键数据有备份或校验机制

## 14. 扩展性原则
- **配置驱动**：通过配置文件控制游戏参数
- **插件架构**：新功能可以通过插件方式添加
- **策略模式**：对于不同算法或行为采用策略模式
- **工厂模式**：对象创建使用工厂模式便于扩展

## 15. 错误处理原则
- **异常安全**：代码具有适当的异常处理机制
- **边界检查**：对数组、列表等进行边界检查
- **状态验证**：在执行操作前验证前置条件
- **用户友好**：错误信息对用户友好且有助于问题解决

## 检查清单
每次编写代码时，请确认是否符合以上设计原则：

### 架构层面
- [ ] 代码属于正确的模块（Data/Systems/Controllers/UI）
- [ ] 遵循单一职责原则
- [ ] 模块间依赖关系清晰
- [ ] 遵循继承体系和多态原则

### 数据层面
- [ ] 数据结构定义清晰且完整
- [ ] 数据验证机制到位
- [ ] 序列化支持正确实现
- [ ] 数据访问接口统一

### 功能层面
- [ ] 通过适当的方式进行系统间通信（事件、方法调用等）
- [ ] 代码具有良好的可读性和注释
- [ ] 符合游戏阶段化流程设计
- [ ] 考虑了性能和可测试性

### 游戏设计层面
- [ ] 遵循游戏机制设计原则
- [ ] 系统交互符合解耦原则
- [ ] 用户体验考虑周全
- [ ] 错误处理机制健全

### 代码质量
- [ ] 命名规范一致
- [ ] 注释充分且准确
- [ ] 避免重复代码
- [ ] 代码结构清晰