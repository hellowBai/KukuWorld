# PetCollector 项目设计原则

## 1. 模块化设计原则
- **功能分离**：将游戏功能按职责划分为不同的模块（数据、系统、控制器、UI）
- **低耦合高内聚**：每个模块专注于单一职责，模块间依赖关系清晰
- **易于扩展**：新功能可以方便地添加到相应模块中

## 2. 数据驱动设计
- **数据结构先行**：先定义清晰的数据结构，再实现相应功能
- **统一数据访问**：通过专门的数据类管理游戏数据
- **数据验证**：对输入和输出数据进行验证，确保数据一致性

## 3. 阶段化游戏流程
- **明确阶段划分**：捕捉阶段和防守阶段有明确的边界和转换条件
- **状态管理**：通过状态机管理游戏的不同阶段
- **时间约束**：捕捉阶段有明确的时间限制，增加游戏节奏感

## 4. 继承与多态原则
- **继承体系**：MythicalPetData继承PetData，体现类型层次
- **多态实现**：通过重写方法实现不同类型对象的差异化行为
- **接口统一**：提供统一的接口供其他系统调用

## 5. 事件驱动架构
- **松耦合通信**：系统间通过事件进行通信，降低依赖关系
- **响应式设计**：系统能够响应各种游戏事件并做出相应处理
- **可扩展性**：新的监听者可以轻松加入事件系统

## 6. 渐进式复杂度
- **简单起步**：从基础功能开始，逐步增加复杂特性
- **迭代开发**：每个版本都建立在稳定的基础上
- **平衡性考虑**：在增加复杂度的同时保持游戏平衡

## 7. 用户体验优先
- **直观操作**：游戏机制设计直观易懂
- **及时反馈**：给玩家及时的操作反馈
- **进度感知**：让玩家清楚自己的进展和目标

## 8. 可维护性原则
- **代码清晰**：良好的命名规范和注释
- **结构化组织**：合理的目录结构和文件组织
- **文档完备**：完善的设计文档和API说明

## 9. 性能考虑
- **资源管理**：合理管理游戏资源，避免内存泄漏
- **对象池**：对频繁创建销毁的对象使用对象池
- **优化时机**：在不影响开发效率的前提下考虑性能优化

## 10. 可测试性
- **单元测试友好**：设计便于单元测试的代码结构
- **模拟对象**：为依赖项提供模拟实现
- **功能独立**：确保各功能模块可以独立测试

## 11. 游戏机制设计原则
- **捕捉机制**：前5分钟捕捉野怪，野怪死亡后掉落灵魂、金钱、宠物蛋
- **进化机制**：宠物通过吸收野怪灵魂进化，提升稀有度和属性
- **融合机制**：进化到最终等级的宠物可与特定机器人融合
- **装备机制**：融合后的终极单位可装备六件装备
- **防守机制**：使用捕捉到的宠物和建造的防御设施抵御敌人

## 12. 系统交互原则
- **单一职责**：每个系统只负责特定的功能领域
- **依赖注入**：通过接口或构造函数注入依赖，而非硬编码
- **数据流清晰**：数据流向明确，避免循环依赖
- **事件解耦**：系统间通过事件通信，降低耦合度

## 检查清单
每次编写代码时，请确认是否符合以上设计原则：
- [ ] 代码属于正确的模块（Data/Systems/Controllers/UI）
- [ ] 数据结构定义清晰且完整
- [ ] 遵循继承体系和多态原则
- [ ] 通过适当的方式进行系统间通信（事件、方法调用等）
- [ ] 代码具有良好的可读性和注释
- [ ] 符合游戏阶段化流程设计
- [ ] 考虑了性能和可测试性
- [ ] 遵循游戏机制设计原则
- [ ] 系统交互符合解耦原则