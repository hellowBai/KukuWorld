# KukuWorld 游戏用户界面设计文档

## 1. UI系统概述

KukuWorld 的用户界面系统采用模块化设计，支持捕捉阶段和防守阶段的不同界面需求。UI系统包括通用组件、捕捉界面、战斗界面、商店界面等多个模块，确保玩家在不同游戏阶段都能获得良好的操作体验。

## 2. UI架构

### 2.1 UIManager (UI管理器)
- **职责**: 统一管理所有UI界面的显示和隐藏
- **类型**: 单例系统
- **依赖**: 各个UI控制器

### 2.2 专用界面控制器
- **CaptureUIController**: 捕捉阶段界面
- **ShopUIController**: 商店界面
- **FusionUIController**: 融合界面
- **BattleUIController**: 战斗界面
- **InventoryUIController**: 背包界面

## 3. UIManager (UI管理器)

### 3.1 类定义
```csharp
public class KukuUIManager : MonoBehaviour
```

### 3.2 系统职责
- 管理所有UI界面的生命周期
- 处理界面间的切换和状态管理
- 统一管理UI动画和过渡效果
- 提供全局UI操作接口

### 3.3 数据结构

#### 3.3.1 UI配置参数
```csharp
[Header("UI设置")]
public Canvas mainCanvas;                          // 主画布
public GameObject loadingScreen;                   // 加载界面
public GameObject notificationPanel;               // 通知面板
public TextMeshProUGUI notificationText;          // 通知文本
public AudioSource uiAudioSource;                 // UI音效源

// UI面板引用
public GameObject[] uiPanels;                      // 所有UI面板数组
private Dictionary<Type, GameObject> uiPanelsMap;  // UI面板字典映射
private Stack<GameObject> panelStack;              // 面板堆栈（用于返回功能）
```

#### 3.3.2 UI状态
```csharp
private bool isUIEnabled = true;                   // UI是否启用
private float uiAnimationDuration = 0.3f;         // UI动画持续时间
private Dictionary<string, object> uiDataCache;   // UI数据缓存
```

#### 3.3.3 事件系统
```csharp
public event Action<string> OnUINotification;      // UI通知事件
public event Action<Type> OnUIDisplayed;           // UI显示事件
public event Action<Type> OnUIHidden;              // UI隐藏事件
```

### 3.4 核心方法

#### 3.4.1 初始化方法
```csharp
/// <summary>
/// 初始化UI管理器
/// </summary>
public void Initialize()
{
    try
    {
        // 初始化数据结构
        uiPanelsMap = new Dictionary<Type, GameObject>();
        panelStack = new Stack<GameObject>();
        uiDataCache = new Dictionary<string, object>();
        
        // 注册所有UI面板
        RegisterUIPanels();
        
        Debug.Log("UI管理器初始化完成");
    }
    catch (Exception e)
    {
        Debug.LogError($"UI管理器初始化失败: {e.Message}");
    }
}

/// <summary>
/// 注册UI面板
/// </summary>
private void RegisterUIPanels()
{
    if (uiPanels != null)
    {
        foreach (GameObject panel in uiPanels)
        {
            if (panel != null)
            {
                // 获取面板的类型（通过组件）
                MonoBehaviour[] components = panel.GetComponents<MonoBehaviour>();
                foreach (MonoBehaviour component in components)
                {
                    if (component != null && component.GetType() != typeof(KukuUIManager))
                    {
                        uiPanelsMap[component.GetType()] = panel;
                    }
                }
            }
        }
    }
}
```

#### 3.4.2 界面显示方法
```csharp
/// <summary>
/// 显示指定类型的UI面板
/// </summary>
public void ShowUI<T>() where T : MonoBehaviour
{
    Type uiType = typeof(T);
    
    if (uiPanelsMap.ContainsKey(uiType))
    {
        GameObject panel = uiPanelsMap[uiType];
        
        if (panel != null)
        {
            // 隐藏其他面板（除了通用面板）
            HideOtherPanels(panel);
            
            // 显示目标面板
            panel.SetActive(true);
            
            // 添加到堆栈
            panelStack.Push(panel);
            
            // 触发事件
            OnUIDisplayed?.Invoke(uiType);
            
            Debug.Log($"显示UI面板: {uiType.Name}");
        }
    }
    else
    {
        Debug.LogWarning($"未找到UI面板: {uiType.Name}");
    }
}

/// <summary>
/// 隐藏指定类型的UI面板
/// </summary>
public void HideUI<T>() where T : MonoBehaviour
{
    Type uiType = typeof(T);
    
    if (uiPanelsMap.ContainsKey(uiType))
    {
        GameObject panel = uiPanelsMap[uiType];
        
        if (panel != null)
        {
            panel.SetActive(false);
            
            // 从堆栈中移除
            if (panelStack.Count > 0 && panelStack.Peek() == panel)
            {
                panelStack.Pop();
            }
            
            // 触发事件
            OnUIHidden?.Invoke(uiType);
            
            Debug.Log($"隐藏UI面板: {uiType.Name}");
        }
    }
}

/// <summary>
/// 切换UI面板
/// </summary>
public void ToggleUI<T>() where T : MonoBehaviour
{
    Type uiType = typeof(T);
    
    if (uiPanelsMap.ContainsKey(uiType))
    {
        GameObject panel = uiPanelsMap[uiType];
        
        if (panel != null)
        {
            panel.SetActive(!panel.activeSelf);
            
            if (panel.activeSelf)
            {
                panelStack.Push(panel);
                OnUIDisplayed?.Invoke(uiType);
            }
            else
            {
                if (panelStack.Count > 0 && panelStack.Peek() == panel)
                {
                    panelStack.Pop();
                }
                OnUIHidden?.Invoke(uiType);
            }
        }
    }
}

/// <summary>
/// 隐藏其他面板
/// </summary>
private void HideOtherPanels(GameObject exceptPanel)
{
    foreach (GameObject panel in uiPanelsMap.Values)
    {
        if (panel != null && panel != exceptPanel && !IsCommonPanel(panel))
        {
            panel.SetActive(false);
        }
    }
}

/// <summary>
/// 检查是否为通用面板
/// </summary>
private bool IsCommonPanel(GameObject panel)
{
    // 通用面板通常包括通知、加载界面等
    return panel == notificationPanel || panel == loadingScreen;
}
```

#### 3.4.3 通知系统方法
```csharp
/// <summary>
/// 显示通知
/// </summary>
public void ShowNotification(string message, float duration = 3f)
{
    if (notificationPanel != null && notificationText != null)
    {
        notificationText.text = message;
        notificationPanel.SetActive(true);
        
        // 自动隐藏通知
        StartCoroutine(HideNotificationAfterDelay(duration));
        
        // 触发事件
        OnUINotification?.Invoke(message);
        
        Debug.Log($"通知: {message}");
    }
}

/// <summary>
/// 延迟隐藏通知
/// </summary>
private IEnumerator HideNotificationAfterDelay(float delay)
{
    yield return new WaitForSeconds(delay);
    
    if (notificationPanel != null)
    {
        notificationPanel.SetActive(false);
    }
}

/// <summary>
/// 显示加载界面
/// </summary>
public void ShowLoadingScreen(string message = "")
{
    if (loadingScreen != null)
    {
        loadingScreen.SetActive(true);
        
        // 设置加载信息（如果有文本组件）
        TextMeshProUGUI loadingText = loadingScreen.GetComponentInChildren<TextMeshProUGUI>();
        if (loadingText != null && !string.IsNullOrEmpty(message))
        {
            loadingText.text = message;
        }
    }
}

/// <summary>
/// 隐藏加载界面
/// </summary>
public void HideLoadingScreen()
{
    if (loadingScreen != null)
    {
        loadingScreen.SetActive(false);
    }
}
```

#### 3.4.4 导航方法
```csharp
/// <summary>
/// 返回上一个界面
/// </summary>
public void GoBack()
{
    if (panelStack.Count > 1)
    {
        GameObject currentPanel = panelStack.Pop();
        
        if (currentPanel != null)
        {
            currentPanel.SetActive(false);
            OnUIHidden?.Invoke(currentPanel.GetComponent<MonoBehaviour>().GetType());
        }
        
        if (panelStack.Count > 0)
        {
            GameObject previousPanel = panelStack.Peek();
            
            if (previousPanel != null)
            {
                previousPanel.SetActive(true);
                OnUIDisplayed?.Invoke(previousPanel.GetComponent<MonoBehaviour>().GetType());
            }
        }
    }
    else if (panelStack.Count == 1)
    {
        GameObject currentPanel = panelStack.Pop();
        
        if (currentPanel != null)
        {
            currentPanel.SetActive(false);
            OnUIHidden?.Invoke(currentPanel.GetComponent<MonoBehaviour>().GetType());
        }
    }
}

/// <summary>
/// 清空界面堆栈
/// </summary>
public void ClearPanelStack()
{
    panelStack.Clear();
}
```

#### 3.4.5 数据缓存方法
```csharp
/// <summary>
/// 缓存UI数据
/// </summary>
public void CacheUIData(string key, object data)
{
    if (uiDataCache.ContainsKey(key))
    {
        uiDataCache[key] = data;
    }
    else
    {
        uiDataCache.Add(key, data);
    }
}

/// <summary>
/// 获取缓存的UI数据
/// </summary>
public T GetCachedUIData<T>(string key)
{
    if (uiDataCache.ContainsKey(key))
    {
        return (T)uiDataCache[key];
    }
    
    return default(T);
}

/// <summary>
/// 清除缓存的UI数据
/// </summary>
public void ClearCachedUIData(string key)
{
    if (uiDataCache.ContainsKey(key))
    {
        uiDataCache.Remove(key);
    }
}
```

## 4. CaptureUIController (捕捉界面控制器)

### 4.1 类定义
```csharp
public class CaptureUIController : MonoBehaviour
```

### 4.2 系统职责
- 管理捕捉阶段的用户界面
- 显示野生KuKu信息
- 处理捕捉操作界面
- 显示捕捉阶段倒计时

### 4.3 数据结构

#### 4.3.1 界面组件
```csharp
[Header("捕捉面板")]
public GameObject capturePanel;                    // 捕捉面板
public Button closeCaptureButton;                   // 关闭按钮

[Header("野生KuKu显示")]
public Transform wildKukuContainer;                 // 野生KuKu容器
public GameObject wildKukuCardPrefab;               // 野生KuKu卡片预制体

[Header("选中KuKu信息显示")]
public TextMeshProUGUI selectedKukuNameText;        // 选中KuKu名称
public TextMeshProUGUI selectedKukuRarityText;      // 选中KuKu稀有度
public TextMeshProUGUI selectedKukuHpText;          // 选中KuKu生命值
public Slider selectedKukuHpSlider;                 // 选中KuKu生命值滑动条
public TextMeshProUGUI captureStatusText;          // 捕捉状态
public TextMeshProUGUI captureSuccessRateText;     // 捕捉成功率
public TextMeshProUGUI capturePhaseTimerText;      // 捕捉阶段倒计时

[Header("操作按钮")]
public Button attackButton;                        // 攻击按钮
public Button useKukuAttackButton;                 // 使用KuKu攻击按钮
public Button captureButton;                       // 捕捉按钮
public Button useSpecialCaptureButton;             // 使用特殊捕捉按钮
public Button soulAbsorbButton;                    // 灵魂吸收按钮

[Header("玩家KuKu选择")]
public Transform playerKukuSelectionPanel;          // 玩家KuKu选择面板
public GameObject playerKukuCardPrefab;             // 玩家KuKu卡片预制体
```

#### 4.3.2 状态数据
```csharp
private CaptureSystem.WildKuku? selectedWildKuku;    // 选中的野生KuKu
private MythicalKukuData selectedCapturerKuku;       // 选中的捕捉者KuKu
private List<MythicalKukuData> playerKukus;          // 玩家的KuKu列表
```

### 4.4 核心方法

#### 4.4.1 初始化方法
```csharp
/// <summary>
/// 初始化捕捉界面
/// </summary>
public void Initialize()
{
    // 初始化按钮事件
    InitializeButtonEvents();
    
    // 初始化显示
    UpdateCaptureTimerDisplay(CaptureSystem.GetCapturePhaseRemainingTime());
    
    Debug.Log("捕捉界面控制器初始化完成");
}

/// <summary>
/// 初始化按钮事件
/// </summary>
private void InitializeButtonEvents()
{
    if (closeCaptureButton != null)
        closeCaptureButton.onClick.AddListener(CloseCapturePanel);
        
    if (attackButton != null)
        attackButton.onClick.AddListener(() => AttackSelectedWildKuku(false));
        
    if (useKukuAttackButton != null)
        useKukuAttackButton.onClick.AddListener(() => AttackSelectedWildKuku(true));
        
    if (captureButton != null)
        captureButton.onClick.AddListener(() => AttemptCaptureSelectedKuku(false));
        
    if (useSpecialCaptureButton != null)
        useSpecialCaptureButton.onClick.AddListener(() => AttemptCaptureSelectedKuku(true));
        
    if (soulAbsorbButton != null)
        soulAbsorbButton.onClick.AddListener(AttemptSoulAbsorption);
}
```

#### 4.4.2 界面控制方法
```csharp
/// <summary>
/// 打开捕捉面板
/// </summary>
public void OpenCapturePanel()
{
    if (capturePanel != null)
        capturePanel.SetActive(true);
        
    RefreshWildKukuList();
    RefreshPlayerKukuSelection();
}

/// <summary>
/// 关闭捕捉面板
/// </summary>
public void CloseCapturePanel()
{
    if (capturePanel != null)
        capturePanel.SetActive(false);
        
    selectedWildKuku = null;
    selectedCapturerKuku = null;
}
```

## 5. ShopUIController (商店界面控制器)

### 5.1 类定义
```csharp
public class ShopUIController : MonoBehaviour
```

### 5.2 系统职责
- 管理商店界面和购买逻辑
- 显示可购买的商品
- 处理购买交易

### 5.3 数据结构

#### 5.3.1 界面组件
```csharp
[Header("商店面板")]
public GameObject shopPanel;                       // 商店面板
public Button closeShopButton;                      // 关闭按钮
public Button refreshInventoryButton;               // 刷新库存按钮

[Header("商品展示")]
public Transform shopItemContainer;                 // 商品容器
public GameObject shopItemCardPrefab;               // 商品卡片预制体

[Header("商品详情")]
public TextMeshProUGUI selectedItemNameText;        // 选中商品名称
public TextMeshProUGUI selectedItemDescriptionText; // 选中商品描述
public TextMeshProUGUI selectedItemPriceText;       // 选中商品价格
public Image selectedItemIcon;                      // 选中商品图标

[Header("玩家信息")]
public TextMeshProUGUI playerCoinsText;             // 玩家金币显示
public TextMeshProUGUI playerGemsText;              // 玩家神石显示
public TextMeshProUGUI playerSoulsText;             // 玩家灵魂显示

[Header("购买按钮")]
public Button purchaseButton;                       // 购买按钮
public Button buyCoinsButton;                       // 购买金币按钮
public Button buyGemsButton;                        // 购买神石按钮
```

#### 5.3.2 状态数据
```csharp
private List<EquipmentSystem.ShopItem> shopInventory; // 商店库存
private EquipmentSystem.ShopItem? selectedItem;       // 选中商品
```

## 6. FusionUIController (融合界面控制器)

### 6.1 类定义
```csharp
public class FusionUIController : MonoBehaviour
```

### 6.2 系统职责
- 管理KuKu与机器人融合界面
- 显示融合要求和结果
- 处理融合操作

### 6.3 数据结构

#### 6.3.1 界面组件
```csharp
[Header("融合面板")]
public GameObject fusionPanel;                      // 融合面板
public Button closeFusionButton;                    // 关闭按钮
public Button startFusionButton;                    // 开始融合按钮

[Header("KuKu选择")]
public Transform kukuSelectionPanel;                // KuKu选择面板
public GameObject kukuCardPrefab;                   // KuKu卡片预制体

[Header("机器人选择")]
public Transform robotSelectionPanel;               // 机器人选择面板
public GameObject robotCardPrefab;                  // 机器人卡片预制体

[Header("融合结果")]
public TextMeshProUGUI fusionResultText;            // 融合结果文本
public Image fusionResultImage;                     // 融合结果图像
public TextMeshProUGUI fusionResultDescription;     // 融合结果描述

[Header("融合要求显示")]
public TextMeshProUGUI fusionRequirementsText;      // 融合要求文本
public TextMeshProUGUI playerResourcesText;         // 玩家资源文本
```

## 7. UI设计原则

### 7.1 一致性原则
- 统一的视觉风格和色彩方案
- 一致的交互模式和反馈机制
- 标准化的布局和组件使用

### 7.2 易用性原则
- 直观的界面布局
- 清晰的信息层级
- 明确的操作反馈

### 7.3 响应性原则
- 适配不同屏幕尺寸
- 快速的界面响应
- 流畅的动画过渡

## 8. UI资源管理

### 8.1 资源分类
- UI精灵资源
- UI字体资源
- UI音效资源
- UI动画资源

### 8.2 优化策略
- UI图集合并
- 对象池复用
- 按需加载

## 9. 测试策略

### 9.1 功能测试
- 界面显示测试
- 交互功能测试
- 数据绑定测试

### 9.2 性能测试
- UI渲染性能
- 内存占用测试
- 响应时间测试

## 10. 扩展性考虑

### 10.1 模块化设计
- 可插拔的UI组件
- 配置驱动的界面
- 主题切换支持

### 10.2 多语言支持
- 本地化文本管理
- 文本自适应布局
- 文化适应性设计