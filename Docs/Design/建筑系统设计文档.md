# 宠物收集塔防游戏《Pet Collector》建筑系统设计文档

## 1. 系统概述

建筑系统是《Pet Collector》游戏的核心玩法之一，在防守阶段发挥重要作用。玩家可以建造防御塔、研究所、生产工厂等建筑，利用捕捉到的宠物和建筑生产的单位抵御敌人。系统包含建筑建造、升级、管理等功能。

## 2. 系统架构

### 2.1 BuildingManager (建筑管理器)
- **职责**: 管理所有建筑实例，处理建筑建造和升级
- **类型**: 游戏系统类
- **依赖**: BuildingData, PlayerData, GameManager

## 3. BuildingManager (建筑管理器)

### 3.1 类定义
```csharp
public class BuildingManager : MonoBehaviour
```

### 3.2 系统职责
- 管理所有建筑实例
- 处理建筑建造和升级
- 控制建筑在不同阶段的激活状态
- 管理建筑的生产队列
- 处理建筑之间的协同效应

### 3.3 数据结构

#### 3.3.1 配置参数
```csharp
[Header("建筑系统配置")]
public float baseBuildTimeMultiplier = 1.0f;      // 基础建造时间倍数
public float baseUpgradeTimeMultiplier = 1.0f;    // 基础升级时间倍数
public int maxBuildingsPerType = 10;              // 每种建筑的最大数量
public float buildingPlacementGridSize = 1.0f;    // 建筑放置网格大小
```

#### 3.3.2 建筑数据
```csharp
// 建筑建造信息
public struct BuildingConstructionInfo
{
    public BuildingData building;      // 建筑数据
    public Vector3 position;          // 建筑位置
    public float constructionTime;    // 剩余建造时间
    public bool isBeingBuilt;         // 是否正在建造
    public System.Action onComplete;  // 建造完成回调

    public BuildingConstructionInfo(BuildingData b, Vector3 pos, float time, System.Action callback = null)
    {
        building = b;
        position = pos;
        constructionTime = time;
        isBeingBuilt = true;
        onComplete = callback;
    }
}
```

#### 3.3.3 生产队列
```csharp
// 单位生产信息
public struct UnitProductionInfo
{
    public UnitData unit;              // 要生产的单位
    public BuildingData producer;      // 生产建筑
    public float productionTime;       // 剩余生产时间
    public bool isProducing;          // 是否正在生产
    public System.Action<UnitData> onComplete; // 生产完成回调

    public UnitProductionInfo(UnitData u, BuildingData b, float time, System.Action<UnitData> callback = null)
    {
        unit = u;
        producer = b;
        productionTime = time;
        isProducing = true;
        onComplete = callback;
    }
}
```

### 3.4 核心方法

#### 3.4.1 建造建筑方法
```csharp
/// <summary>
/// 建造建筑
/// </summary>
public bool BuildBuilding(BuildingData building, Vector3 position)
{
    // 检查输入参数
    if (building == null)
    {
        Debug.LogError("建筑数据为空！");
        return false;
    }

    // 检查玩家是否有足够资源
    var buildCost = building.GetBuildCost();
    if (!GameManager.Instance.PlayerData.HasResources(buildCost.coins, buildCost.gems))
    {
        Debug.Log($"资源不足，需要 {buildCost.coins} 金币和 {buildCost.gems} 神石");
        return false;
    }

    // 检查是否超过该类型建筑的最大数量
    int currentCount = GetBuildingsOfType(building.Type).Count;
    if (currentCount >= maxBuildingsPerType)
    {
        Debug.Log($"该类型建筑已达上限 ({maxBuildingsPerType})");
        return false;
    }

    // 检查是否可以在此阶段建造
    if (!building.CanBuildInCurrentPhase(GameManager.Instance.CurrentState))
    {
        Debug.Log("当前游戏阶段无法建造此类型建筑");
        return false;
    }

    // 检查位置是否合适（例如是否有其他建筑阻挡）
    if (!IsValidBuildingPosition(position, building))
    {
        Debug.Log("建筑位置不合适");
        return false;
    }

    // 消耗资源
    GameManager.Instance.PlayerData.ConsumeResources(buildCost.coins, buildCost.gems);

    // 计算建造时间
    float buildTime = building.BuildTime * baseBuildTimeMultiplier;

    // 如果建造时间很短，直接完成建造
    if (buildTime <= 0)
    {
        // 创建建筑实例
        BuildingData builtBuilding = CreateBuildingInstance(building, position);
        
        // 添加到已建造列表
        GameManager.Instance.PlayerData.BuiltBuildings.Add(builtBuilding);
        
        Debug.Log($"建筑 {builtBuilding.Name} 建造完成！");
        return true;
    }
    else
    {
        // 开始建造过程
        BuildingConstructionInfo construction = new BuildingConstructionInfo(
            building, position, buildTime, 
            () => OnBuildingConstructionComplete(building, position));

        // 这里可以添加到建造队列中进行管理
        StartCoroutine(ConstructionCoroutine(construction));
        
        Debug.Log($"开始建造 {building.Name}，预计需要 {buildTime:F1} 秒");
        return true;
    }
}

/// <summary>
/// 创建建筑实例
/// </summary>
private BuildingData CreateBuildingInstance(BuildingData template, Vector3 position)
{
    BuildingData instance = new BuildingData();
    
    // 复制模板数据
    System.Reflection.PropertyInfo[] properties = typeof(BuildingData).GetProperties();
    foreach (var prop in properties)
    {
        if (prop.CanRead && prop.CanWrite)
        {
            prop.SetValue(instance, prop.GetValue(template));
        }
    }
    
    // 生成唯一ID
    instance.Id = UnityEngine.Random.Range(10000, 99999);
    
    // 设置初始状态
    instance.IsActive = true;
    instance.CurrentHealth = instance.Health;
    
    return instance;
}
```

#### 3.4.2 升级建筑方法
```csharp
/// <summary>
/// 升级建筑
/// </summary>
public bool UpgradeBuilding(int buildingId)
{
    // 查找指定ID的建筑
    BuildingData building = null;
    foreach (var b in GameManager.Instance.PlayerData.BuiltBuildings)
    {
        if (b.Id == buildingId)
        {
            building = b;
            break;
        }
    }

    if (building == null)
    {
        Debug.LogError($"找不到ID为 {buildingId} 的建筑");
        return false;
    }

    // 检查建筑是否可升级
    if (!building.IsUpgradeable)
    {
        Debug.Log("该建筑不可升级");
        return false;
    }

    // 检查是否已达到最大等级
    if (building.Level >= building.MaxResearchLevel)
    {
        Debug.Log("建筑已达到最大等级");
        return false;
    }

    // 获取升级成本
    var upgradeCost = building.GetUpgradeCost();
    if (!GameManager.Instance.PlayerData.HasResources(upgradeCost.coins, upgradeCost.gems))
    {
        Debug.Log($"升级资源不足，需要 {upgradeCost.coins} 金币和 {upgradeCost.gems} 神石");
        return false;
    }

    // 消耗升级资源
    GameManager.Instance.PlayerData.ConsumeResources(upgradeCost.coins, upgradeCost.gems);

    // 执行升级
    building.Upgrade();

    Debug.Log($"建筑 {building.Name} 升级到 {building.Level} 级！");
    return true;
}
```

#### 3.4.3 建筑管理方法
```csharp
/// <summary>
/// 激活所有建筑（根据当前阶段）
/// </summary>
public void ActivateBuildingsForPhase(GameManager.GameState phase)
{
    foreach (var building in GameManager.Instance.PlayerData.BuiltBuildings)
    {
        // 根据当前游戏阶段决定是否激活建筑
        if (phase == GameManager.GameState.DefensePhase)
        {
            // 在防守阶段，激活所有建筑
            if (!building.IsActive)
            {
                building.Activate();
            }
        }
        else if (phase == GameManager.GameState.CapturePhase)
        {
            // 在捕捉阶段，只激活特定建筑
            if (building.IsActiveDuringCapturePhase)
            {
                if (!building.IsActive)
                {
                    building.Activate();
                }
            }
            else
            {
                // 非捕捉阶段建筑应停用
                if (building.IsActive)
                {
                    building.Deactivate();
                }
            }
        }
    }
}

/// <summary>
/// 更新建筑逻辑
/// </summary>
public void UpdateBuildings(float deltaTime)
{
    // 更新所有已激活的建筑
    foreach (var building in GameManager.Instance.PlayerData.BuiltBuildings)
    {
        if (building.IsActive)
        {
            UpdateBuildingLogic(building, deltaTime);
        }
    }
}

/// <summary>
/// 更新单个建筑逻辑
/// </summary>
private void UpdateBuildingLogic(BuildingData building, float deltaTime)
{
    switch (building.Type)
    {
        case BuildingData.BuildingType.Tower:
            UpdateTowerLogic(building, deltaTime);
            break;
        case BuildingData.BuildingType.Production:
            UpdateProductionLogic(building, deltaTime);
            break;
        case BuildingData.BuildingType.Research:
            UpdateResearchLogic(building, deltaTime);
            break;
        case BuildingData.BuildingType.SoulCollector:
            UpdateSoulCollectorLogic(building, deltaTime);
            break;
        default:
            // 其他类型建筑的更新逻辑
            break;
    }
}
```

#### 3.4.4 建筑特定逻辑更新方法
```csharp
/// <summary>
/// 更新防御塔逻辑
/// </summary>
private void UpdateTowerLogic(BuildingData tower, float deltaTime)
{
    // 防御塔的主要功能是攻击附近的敌人
    if (GameManager.Instance?.CurrentState != GameManager.GameState.DefensePhase) return;
    
    // 查找范围内的敌人
    var battleSystem = FindObjectOfType<BattleSystem>();
    if (battleSystem != null)
    {
        var activeEnemies = battleSystem.GetActiveEnemies();
        
        foreach (var enemyObj in activeEnemies)
        {
            if (enemyObj == null) continue;
            
            // 计算距离
            float distance = Vector3.Distance(enemyObj.transform.position, Vector3.zero); // 假设塔在原点附近
            
            // 如果在射程内，进行攻击
            if (distance <= tower.Range)
            {
                EnemyController enemyCtrl = enemyObj.GetComponent<EnemyController>();
                if (enemyCtrl != null)
                {
                    // 对敌人造成伤害
                    enemyCtrl.TakeDamage(tower.AttackPower * deltaTime); // 按时间比例计算伤害
                    break; // 只攻击一个敌人
                }
            }
        }
    }
}

/// <summary>
/// 更新生产建筑逻辑
/// </summary>
private void UpdateProductionLogic(BuildingData building, float deltaTime)
{
    // 生产建筑的主要功能是生产单位
    if (GameManager.Instance?.CurrentState != GameManager.GameState.DefensePhase) return;
    
    // 检查是否可以生产单位
    if (CanProduceUnit(building))
    {
        // 开始生产单位
        StartUnitProduction(building);
    }
}

/// <summary>
/// 更新研究建筑逻辑
/// </summary>
private void UpdateResearchLogic(BuildingData building, float deltaTime)
{
    // 研究建筑的主要功能是提升科技等级
    if (GameManager.Instance?.CurrentState != GameManager.GameState.DefensePhase) return;
    
    // 每秒产出研究点数
    float researchPoints = building.ResearchSpeed * deltaTime;
    
    // 这里可以实现科技研发的逻辑
    // 例如：积累研究点数解锁新单位或升级现有单位
}

/// <summary>
/// 更新灵魂收集器逻辑
/// </summary>
private void UpdateSoulCollectorLogic(BuildingData building, float deltaTime)
{
    // 灵魂收集器的主要功能是在捕捉阶段收集灵魂
    if (GameManager.Instance?.CurrentState != GameManager.GameState.CapturePhase) return;
    
    // 每秒收集灵魂
    float collectedSouls = building.SoulCollectionRate * deltaTime;
    
    if (GameManager.Instance?.PlayerData != null)
    {
        GameManager.Instance.PlayerData.AddSouls(collectedSouls);
    }
}
```

#### 3.4.5 查询方法
```csharp
/// <summary>
/// 获取指定类型的建筑
/// </summary>
public List<BuildingData> GetBuildingsOfType(BuildingData.BuildingType type)
{
    List<BuildingData> result = new List<BuildingData>();
    
    foreach (var building in GameManager.Instance.PlayerData.BuiltBuildings)
    {
        if (building.Type == type)
        {
            result.Add(building);
        }
    }
    
    return result;
}

/// <summary>
/// 获取可生产指定单位的建筑
/// </summary>
public List<BuildingData> GetProductionBuildingsForUnit(UnitData.UnitType unitType)
{
    List<BuildingData> result = new List<BuildingData>();
    
    foreach (var building in GameManager.Instance.PlayerData.BuiltBuildings)
    {
        if (building.Type == BuildingData.BuildingType.Production && 
            building.ProducesUnitType == unitType)
        {
            result.Add(building);
        }
    }
    
    return result;
}

/// <summary>
/// 检查建筑位置是否有效
/// </summary>
private bool IsValidBuildingPosition(Vector3 position, BuildingData building)
{
    // 检查是否有其他建筑占据该位置
    foreach (var existingBuilding in GameManager.Instance.PlayerData.BuiltBuildings)
    {
        float distance = Vector3.Distance(position, GetBuildingPosition(existingBuilding));
        if (distance < buildingPlacementGridSize)
        {
            return false; // 位置太近
        }
    }
    
    // 这里可以添加更多的位置检查逻辑
    // 例如：地形是否适合、是否在指定区域内等
    
    return true;
}

/// <summary>
/// 获取建筑的位置（这是一个简化的方法，实际中可能需要更复杂的实现）
/// </summary>
private Vector3 GetBuildingPosition(BuildingData building)
{
    // 在实际实现中，这应该返回建筑在游戏世界中的真实位置
    // 这里返回一个占位符
    return Vector3.zero;
}
```

#### 3.4.6 生产相关方法
```csharp
/// <summary>
/// 检查是否可以生产单位
/// </summary>
private bool CanProduceUnit(BuildingData building)
{
    // 检查建筑是否为生产类型
    if (building.Type != BuildingData.BuildingType.Production) return false;
    
    // 检查是否已有生产队列
    // 这里可以实现生产队列的检查逻辑
    
    return true;
}

/// <summary>
/// 开始单位生产
/// </summary>
private void StartUnitProduction(BuildingData building)
{
    // 创建要生产的单位
    UnitData unitToProduce = new UnitData();
    unitToProduce.Type = building.ProducesUnitType;
    unitToProduce.Name = $"Production_{building.ProducesUnitType}";
    unitToProduce.Description = $"由 {building.Name} 生产的单位";
    
    // 设置单位属性
    switch (building.ProducesUnitType)
    {
        case UnitData.UnitType.Robot:
            unitToProduce.AttackPower = 20f + building.Level * 5f;
            unitToProduce.DefensePower = 10f + building.Level * 3f;
            unitToProduce.Health = 100f + building.Level * 20f;
            unitToProduce.ProductionCost = 100 + building.Level * 20;
            break;
        case UnitData.UnitType.Tank:
            unitToProduce.AttackPower = 40f + building.Level * 8f;
            unitToProduce.DefensePower = 30f + building.Level * 6f;
            unitToProduce.Health = 200f + building.Level * 40f;
            unitToProduce.ProductionCost = 200 + building.Level * 40;
            break;
        // 其他单位类型的设置...
    }
    
    // 计算生产时间
    float productionTime = unitToProduce.ProductionTime / building.ProductionSpeed;
    
    // 创建生产信息
    UnitProductionInfo production = new UnitProductionInfo(
        unitToProduce, building, productionTime,
        (producedUnit) => OnUnitProductionComplete(producedUnit, building));
    
    // 开始生产协程
    StartCoroutine(UnitProductionCoroutine(production));
    
    Debug.Log($"开始生产 {unitToProduce.Name}，预计需要 {productionTime:F1} 秒");
}

/// <summary>
/// 单位生产完成回调
/// </summary>
private void OnUnitProductionComplete(UnitData unit, BuildingData building)
{
    // 将生产的单位添加到玩家单位列表
    if (GameManager.Instance?.PlayerData != null)
    {
        GameManager.Instance.PlayerData.AddDeployedUnit(unit);
        Debug.Log($"{unit.Name} 生产完成！");
    }
}
```

#### 3.4.7 协程方法
```csharp
/// <summary>
/// 建造协程
/// </summary>
private System.Collections.IEnumerator ConstructionCoroutine(BuildingConstructionInfo construction)
{
    float startTime = Time.time;
    float totalTime = construction.constructionTime;
    
    while (construction.constructionTime > 0)
    {
        yield return null; // 等待下一帧
        
        float elapsed = Time.time - startTime;
        construction.constructionTime = totalTime - elapsed;
        
        // 可以在这里添加建造进度的可视化
    }
    
    // 建造完成
    BuildingData builtBuilding = CreateBuildingInstance(construction.building, construction.position);
    GameManager.Instance.PlayerData.BuiltBuildings.Add(builtBuilding);
    
    Debug.Log($"建筑 {builtBuilding.Name} 建造完成！");
    
    // 调用完成回调
    construction.onComplete?.Invoke();
}

/// <summary>
/// 单位生产协程
/// </summary>
private System.Collections.IEnumerator UnitProductionCoroutine(UnitProductionInfo production)
{
    float startTime = Time.time;
    float totalTime = production.productionTime;
    
    while (production.productionTime > 0)
    {
        yield return null; // 等待下一帧
        
        float elapsed = Time.time - startTime;
        production.productionTime = totalTime - elapsed;
        
        // 可以在这里添加生产进度的可视化
    }
    
    // 生产完成
    OnUnitProductionComplete(production.unit, production.producer);
    
    // 调用完成回调
    production.onComplete?.Invoke(production.unit);
}
```

## 4. 系统交互

### 4.1 数据流
```
PlayerData → BuildingManager → BuildingData
UI → BuildingManager → Build/Upgrade Commands
GameManager → BuildingManager → Phase Updates
BattleSystem → BuildingManager → Target Information
```

### 4.2 事件流
- 玩家建造请求 → BuildingManager 验证条件 → 执行建造 → 更新PlayerData → UI更新显示
- 建筑升级请求 → BuildingManager 验证条件 → 执行升级 → 更新建筑属性
- 游戏阶段切换 → BuildingManager 激活/停用建筑 → 建筑状态更新

### 4.3 依赖关系
- BuildingManager 依赖 PlayerData 管理建筑列表
- BuildingManager 依赖 GameManager 获取游戏状态
- BuildingManager 依赖 BattleSystem 进行防御塔攻击
- UI系统依赖 BuildingManager 获取建筑信息