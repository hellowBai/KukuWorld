# Kuku收集塔防游戏《Kuku Collector》装备系统设计文档

## 1. 系统概述

装备系统是《Kuku Collector》游戏的核心玩法之一，允许玩家为融合后的终极单位装备多达六件装备，以大幅提升战斗力。系统包含装备合成、装备穿戴、属性加成等功能。

## 2. 系统架构

### 2.1 EquipmentSystem (装备系统)
- **职责**: 管理装备合成逻辑，处理装备穿戴，计算装备属性加成
- **类型**: 静态系统类
- **依赖**: WeaponData, UnitData, PlayerData

## 3. EquipmentSystem (装备系统)

### 3.1 类定义
```csharp
public static class EquipmentSystem
```

### 3.2 系统职责
- 管理装备合成逻辑
- 处理装备穿戴
- 计算装备属性加成
- 管理商店装备购买
- 验证装备兼容性

### 3.3 数据结构

#### 3.3.1 合成结果结构
```csharp
public struct CombineResult
{
    public bool success;
    public WeaponData combinedWeapon;
    public string message;

    public CombineResult(bool isSuccess, WeaponData weapon, string msg)
    {
        success = isSuccess;
        combinedWeapon = weapon;
        message = msg;
    }
}
```

#### 3.3.2 装备结果结构
```csharp
public struct EquipResult
{
    public bool success;
    public string message;

    public EquipResult(bool isSuccess, string msg)
    {
        success = isSuccess;
        message = msg;
    }
}
```

#### 3.3.3 商店物品结构
```csharp
public struct ShopItem
{
    public WeaponData item;
    public int price;
    public bool isAvailable;

    public ShopItem(WeaponData w, int p, bool available)
    {
        item = w;
        price = p;
        isAvailable = available;
    }
}
```

#### 3.3.4 装备合成规则
```csharp
public static class EquipmentRules
{
    // 合成消耗规则
    public const int BASIC_COMBINE_COST = 50;   // 基础合成消耗
    public const int ADVANCED_COMBINE_COST = 100; // 高级合成消耗
    public const int EXPERT_COMBINE_COST = 200;   // 专家合成消耗
    public const int MASTER_COMBINE_COST = 400;   // 大师合成消耗
    public const int LEGENDARY_COMBINE_COST = 800; // 传说合成消耗

    // 合成成功率规则
    public const float BASIC_COMBINE_SUCCESS_RATE = 0.9f;   // 基础合成成功率
    public const float ADVANCED_COMBINE_SUCCESS_RATE = 0.8f; // 高级合成成功率
    public const float EXPERT_COMBINE_SUCCESS_RATE = 0.7f;   // 专家合成成功率
    public const float MASTER_COMBINE_SUCCESS_RATE = 0.6f;   // 大师合成成功率
    public const float LEGENDARY_COMBINE_SUCCESS_RATE = 0.5f; // 传说合成成功率

    // 装备属性加成规则
    public const float ATTACK_BONUS_MULTIPLIER = 1.15f;  // 攻击加成倍数
    public const float DEFENSE_BONUS_MULTIPLIER = 1.12f; // 防御加成倍数
    public const float SPEED_BONUS_MULTIPLIER = 1.10f;   // 速度加成倍数
    public const float HEALTH_BONUS_MULTIPLIER = 1.10f;   // 血量加成倍数
    public const float RANGE_BONUS_MULTIPLIER = 1.08f;    // 射程加成倍数
}
```

### 3.4 核心方法

#### 3.4.1 合成方法
```csharp
/// <summary>
/// 合成武器
/// </summary>
public static CombineResult CombineWeapons(WeaponData component1, WeaponData component2, string customName = "")
{
    // 检查输入参数
    if (component1 == null || component2 == null)
    {
        return new CombineResult(false, null, "合成组件不能为空！");
    }

    // 检查是否可以合成
    if (!CanCombine(component1, component2))
    {
        return new CombineResult(false, null, "这两个装备无法合成！");
    }

    // 检查玩家是否有足够资源
    int combineCost = GetComponentCombineCost(component1, component2);
    if (GameManager.Instance?.PlayerData.Coins < combineCost)
    {
        return new CombineResult(false, null, $"金币不足，需要 {combineCost} 金币进行合成！");
    }

    // 计算合成成功率
    float successRate = GetCombineSuccessRate(component1, component2);
    
    if (UnityEngine.Random.value <= successRate)
    {
        // 合成成功
        WeaponData combinedWeapon = new WeaponData();
        
        // 设置基本信息
        combinedWeapon.Id = UnityEngine.Random.Range(10000, 99999);
        combinedWeapon.Name = string.IsNullOrEmpty(customName) ? 
            $"{component1.Name}+{component2.Name}" : customName;
        combinedWeapon.Description = $"由{component1.Name}和{component2.Name}合成的强大装备";
        combinedWeapon.Type = GetCombinedType(component1.Type, component2.Type);
        combinedWeapon.Tier = GetCombinedTier(component1.Tier, component2.Tier);
        combinedWeapon.Slot = component1.Slot; // 保持相同的装备槽位
        
        // 合并属性（加权平均并略有提升）
        combinedWeapon.AttackBonus = (component1.AttackBonus + component2.AttackBonus) * EquipmentRules.ATTACK_BONUS_MULTIPLIER;
        combinedWeapon.DefenseBonus = (component1.DefenseBonus + component2.DefenseBonus) * EquipmentRules.DEFENSE_BONUS_MULTIPLIER;
        combinedWeapon.SpeedBonus = (component1.SpeedBonus + component2.SpeedBonus) * EquipmentRules.SPEED_BONUS_MULTIPLIER;
        combinedWeapon.HealthBonus = (component1.HealthBonus + component2.HealthBonus) * EquipmentRules.HEALTH_BONUS_MULTIPLIER;
        combinedWeapon.RangeBonus = (component1.RangeBonus + component2.RangeBonus) * EquipmentRules.RANGE_BONUS_MULTIPLIER;
        combinedWeapon.SpecialEffect = (component1.SpecialEffect + component2.SpecialEffect) * 1.1f; // 特殊效果也有提升
        
        // 设置合成后的新属性
        combinedWeapon.IsCombinable = component1.Tier < WeaponData.WeaponTier.Legendary; // 传说级及以上不可再合成
        combinedWeapon.CombineCost = (int)((component1.CombineCost + component2.CombineCost) * 1.5f); // 合成成本增加
        combinedWeapon.RequiredTierToCombine = (int)combinedWeapon.Tier; // 需要相同等级才能再次合成
        combinedWeapon.ComponentsNeeded = 2; // 需要2个组件
        combinedWeapon.EquipCost = (int)((component1.EquipCost + component2.EquipCost) * 1.2f); // 装备成本略增
        combinedWeapon.RequiredLevel = Mathf.Max(component1.RequiredLevel, component2.RequiredLevel) + 1; // 要求等级提升
        combinedWeapon.Durability = Mathf.Max(component1.Durability, component2.Durability); // 耐久度取最大值
        combinedWeapon.IsEquipped = false; // 新合成的装备未装备
        
        // 消耗资源
        if (GameManager.Instance?.PlayerData != null)
        {
            GameManager.Instance.PlayerData.AddCoins(-combineCost);
        }

        string message = $"合成成功！{combinedWeapon.Name} 已创建，属性全面提升！";
        return new CombineResult(true, combinedWeapon, message);
    }
    else
    {
        // 合成失败，消耗一半的资源
        if (GameManager.Instance?.PlayerData != null)
        {
            GameManager.Instance.PlayerData.AddCoins(-(combineCost / 2));
        }

        return new CombineResult(false, null, $"合成失败！消耗了 {combineCost / 2} 金币。");
    }
}
```

#### 3.4.2 装备方法
```csharp
/// <summary>
/// 为单位装备武器
/// </summary>
public static EquipResult EquipWeapon(object unit, WeaponData weapon)
{
    // 检查输入参数
    if (unit == null || weapon == null)
    {
        return new EquipResult(false, "单位或装备不能为空！");
    }

    // 检查单位类型
    UnitData unitData = null;
    if (unit is UnitData)
    {
        unitData = (UnitData)unit;
    }
    else if (unit is MythicalKukuData)
    {
        // 如果是kuku，暂时返回错误（kuku不能直接装备武器）
        return new EquipResult(false, "kuku无法直接装备武器，需要先与机器人融合！");
    }
    else
    {
        return new EquipResult(false, "不支持的单位类型！");
    }

    // 检查单位是否可以装备
    if (!CanEquip(unitData, weapon))
    {
        return new EquipResult(false, "该单位无法装备此装备！");
    }

    // 检查是否已有相同类型的装备
    if (unitData.EquippedItems.Exists(w => w.Slot == weapon.Slot))
    {
        return new EquipResult(false, $"该单位已在 {weapon.Slot} 槽位装备了其他装备！");
    }

    // 检查装备槽位是否已满
    if (unitData.EquippedItems.Count >= unitData.MaxEquipmentSlots)
    {
        return new EquipResult(false, $"该单位装备槽位已满（最多 {unitData.MaxEquipmentSlots} 个）！");
    }

    // 检查装备等级要求
    if (unitData.Level < weapon.RequiredLevel)
    {
        return new EquipResult(false, $"单位等级不足，需要达到 {weapon.RequiredLevel} 级才能装备此装备！");
    }

    // 检查装备费用
    if (GameManager.Instance?.PlayerData.Coins < weapon.EquipCost)
    {
        return new EquipResult(false, $"金币不足，需要 {weapon.EquipCost} 金币来装备此装备！");
    }

    // 执行装备
    unitData.EquippedItems.Add(weapon);
    weapon.IsEquipped = true;

    // 消耗装备费用
    if (GameManager.Instance?.PlayerData != null)
    {
        GameManager.Instance.PlayerData.AddCoins(-weapon.EquipCost);
    }

    string message = $"{unitData.Name} 成功装备了 {weapon.Name}！属性得到提升！";
    return new EquipResult(true, message);
}
```

#### 3.4.3 卸下装备方法
```csharp
/// <summary>
/// 卸下装备
/// </summary>
public static bool UnequipWeapon(object unit, WeaponData weapon)
{
    // 检查输入参数
    if (unit == null || weapon == null)
    {
        return false;
    }

    UnitData unitData = null;
    if (unit is UnitData)
    {
        unitData = (UnitData)unit;
    }
    else
    {
        return false;
    }

    // 检查装备是否已装备
    if (!unitData.EquippedItems.Contains(weapon))
    {
        return false;
    }

    // 执行卸下
    unitData.EquippedItems.Remove(weapon);
    weapon.IsEquipped = false;

    return true;
}
```

#### 3.4.4 辅助方法
```csharp
/// <summary>
/// 检查是否可以合成
/// </summary>
public static bool CanCombine(WeaponData weapon1, WeaponData weapon2)
{
    if (weapon1 == null || weapon2 == null) return false;
    
    // 检查是否都可合成
    if (!weapon1.IsCombinable || !weapon2.IsCombinable) return false;
    
    // 检查装备槽位是否相同
    if (weapon1.Slot != weapon2.Slot) return false;
    
    // 检查等级要求
    if (weapon1.Tier < (WeaponData.WeaponTier)weapon1.RequiredTierToCombine || 
        weapon2.Tier < (WeaponData.WeaponTier)weapon2.RequiredTierToCombine) return false;
    
    // 检查玩家资源
    int combineCost = GetComponentCombineCost(weapon1, weapon2);
    if (GameManager.Instance?.PlayerData.Coins < combineCost) return false;
    
    return true;
}

/// <summary>
/// 检查单位是否可以装备
/// </summary>
public static bool CanEquip(object unit, WeaponData weapon)
{
    if (unit == null || weapon == null) return false;
    
    // 检查单位类型
    if (!(unit is UnitData)) return false;
    
    UnitData unitData = (UnitData)unit;
    
    // 检查是否有空余装备槽位
    if (unitData.EquippedItems.Count >= unitData.MaxEquipmentSlots) return false;
    
    // 检查是否有相同槽位的装备
    if (unitData.EquippedItems.Exists(w => w.Slot == weapon.Slot)) return false;
    
    // 检查等级要求
    if (unitData.Level < weapon.RequiredLevel) return false;
    
    return true;
}

/// <summary>
/// 获取可用装备槽位
/// </summary>
public static List<WeaponData.EquipmentSlot> GetAvailableSlots(object unit)
{
    List<WeaponData.EquipmentSlot> availableSlots = new List<WeaponData.EquipmentSlot>();
    
    if (!(unit is UnitData)) return availableSlots;
    
    UnitData unitData = (UnitData)unit;
    
    // 获取所有可能的槽位
    WeaponData.EquipmentSlot[] allSlots = (WeaponData.EquipmentSlot[])System.Enum.GetValues(typeof(WeaponData.EquipmentSlot));
    
    foreach (var slot in allSlots)
    {
        // 检查该槽位是否已有装备
        if (!unitData.EquippedItems.Exists(w => w.Slot == slot))
        {
            availableSlots.Add(slot);
        }
    }
    
    return availableSlots;
}

/// <summary>
/// 获取兼容武器类型
/// </summary>
public static List<WeaponData.WeaponType> GetCompatibleWeaponTypes(object unit)
{
    List<WeaponData.WeaponType> compatibleTypes = new List<WeaponData.WeaponType>();
    
    if (!(unit is UnitData)) return compatibleTypes;
    
    UnitData unitData = (UnitData)unit;
    
    // 根据单位类型返回兼容的武器类型
    switch (unitData.Type)
    {
        case UnitData.UnitType.Robot:
            // 机器人可以使用大部分武器类型
            compatibleTypes.AddRange((WeaponData.WeaponType[])System.Enum.GetValues(typeof(WeaponData.WeaponType)));
            break;
            
        case UnitData.UnitType.Tank:
            // 坦克更适合重型武器
            compatibleTypes.Add(WeaponData.WeaponType.Cannon);
            compatibleTypes.Add(WeaponData.WeaponType.Armor);
            compatibleTypes.Add(WeaponData.WeaponType.Engine);
            compatibleTypes.Add(WeaponData.WeaponType.Missile);
            break;
            
        case UnitData.UnitType.Hybrid:
            // 混合单位兼容多种武器
            compatibleTypes.AddRange((WeaponData.WeaponType[])System.Enum.GetValues(typeof(WeaponData.WeaponType)));
            break;
            
        case UnitData.UnitType.KukuHybrid:
            // kuku混合单位可能有特殊的兼容性
            compatibleTypes.AddRange((WeaponData.WeaponType[])System.Enum.GetValues(typeof(WeaponData.WeaponType)));
            // 移除某些不兼容的类型（示例）
            compatibleTypes.RemoveAll(t => t == WeaponData.WeaponType.Processor); // 处理器不适合kuku
            break;
    }
    
    return compatibleTypes;
}

/// <summary>
/// 获取合成成本
/// </summary>
private static int GetComponentCombineCost(WeaponData comp1, WeaponData comp2)
{
    // 根据装备等级计算合成成本
    int baseCost = 0;
    switch (comp1.Tier)
    {
        case WeaponData.WeaponTier.Basic:
            baseCost = EquipmentRules.BASIC_COMBINE_COST;
            break;
        case WeaponData.WeaponTier.Advanced:
            baseCost = EquipmentRules.ADVANCED_COMBINE_COST;
            break;
        case WeaponData.WeaponTier.Expert:
            baseCost = EquipmentRules.EXPERT_COMBINE_COST;
            break;
        case WeaponData.WeaponTier.Master:
            baseCost = EquipmentRules.MASTER_COMBINE_COST;
            break;
        case WeaponData.WeaponTier.Legendary:
            baseCost = EquipmentRules.LEGENDARY_COMBINE_COST;
            break;
    }
    
    // 考虑第二个组件的等级，取较高者
    int comp2Cost = 0;
    switch (comp2.Tier)
    {
        case WeaponData.WeaponTier.Basic:
            comp2Cost = EquipmentRules.BASIC_COMBINE_COST;
            break;
        case WeaponData.WeaponTier.Advanced:
            comp2Cost = EquipmentRules.ADVANCED_COMBINE_COST;
            break;
        case WeaponData.WeaponTier.Expert:
            comp2Cost = EquipmentRules.EXPERT_COMBINE_COST;
            break;
        case WeaponData.WeaponTier.Master:
            comp2Cost = EquipmentRules.MASTER_COMBINE_COST;
            break;
        case WeaponData.WeaponTier.Legendary:
            comp2Cost = EquipmentRules.LEGENDARY_COMBINE_COST;
            break;
    }
    
    return Mathf.Max(baseCost, comp2Cost);
}

/// <summary>
/// 获取合成成功率
/// </summary>
private static float GetCombineSuccessRate(WeaponData comp1, WeaponData comp2)
{
    // 基础成功率
    float baseRate = 0f;
    switch (comp1.Tier)
    {
        case WeaponData.WeaponTier.Basic:
            baseRate = EquipmentRules.BASIC_COMBINE_SUCCESS_RATE;
            break;
        case WeaponData.WeaponTier.Advanced:
            baseRate = EquipmentRules.ADVANCED_COMBINE_SUCCESS_RATE;
            break;
        case WeaponData.WeaponTier.Expert:
            baseRate = EquipmentRules.EXPERT_COMBINE_SUCCESS_RATE;
            break;
        case WeaponData.WeaponTier.Master:
            baseRate = EquipmentRules.MASTER_COMBINE_SUCCESS_RATE;
            break;
        case WeaponData.WeaponTier.Legendary:
            baseRate = EquipmentRules.LEGENDARY_COMBINE_SUCCESS_RATE;
            break;
    }
    
    // 如果两个装备等级不同，取较低的成功率
    float comp2Rate = 0f;
    switch (comp2.Tier)
    {
        case WeaponData.WeaponTier.Basic:
            comp2Rate = EquipmentRules.BASIC_COMBINE_SUCCESS_RATE;
            break;
        case WeaponData.WeaponTier.Advanced:
            comp2Rate = EquipmentRules.ADVANCED_COMBINE_SUCCESS_RATE;
            break;
        case WeaponData.WeaponTier.Expert:
            comp2Rate = EquipmentRules.EXPERT_COMBINE_SUCCESS_RATE;
            break;
        case WeaponData.WeaponTier.Master:
            comp2Rate = EquipmentRules.MASTER_COMBINE_SUCCESS_RATE;
            break;
        case WeaponData.WeaponTier.Legendary:
            comp2Rate = EquipmentRules.LEGENDARY_COMBINE_SUCCESS_RATE;
            break;
    }
    
    return Mathf.Min(baseRate, comp2Rate);
}

/// <summary>
/// 获取合成后的类型
/// </summary>
private static WeaponData.WeaponType GetCombinedType(WeaponData.WeaponType type1, WeaponData.WeaponType type2)
{
    // 如果类型相同，保持原类型
    if (type1 == type2) return type1;
    
    // 不同类型的合成规则（简化版）
    // 例如：剑+盾=骑士武器，炮+激光=超级炮等
    if ((type1 == WeaponData.WeaponType.Sword && type2 == WeaponData.WeaponType.Shield) ||
        (type1 == WeaponData.WeaponType.Shield && type2 == WeaponData.WeaponType.Sword))
    {
        return WeaponData.WeaponType.Armor; // 剑盾合成护甲
    }
    
    if ((type1 == WeaponData.WeaponType.Cannon && type2 == WeaponData.WeaponType.Laser) ||
        (type1 == WeaponData.WeaponType.Laser && type2 == WeaponData.WeaponType.Cannon))
    {
        return WeaponData.WeaponType.Crystal; // 炮+激光=水晶武器
    }
    
    // 默认返回第一个类型
    return type1;
}

/// <summary>
/// 获取合成后的等级
/// </summary>
private static WeaponData.WeaponTier GetCombinedTier(WeaponData.WeaponTier tier1, WeaponData.WeaponTier tier2)
{
    // 取较高等级，如果相同则有可能提升一级
    WeaponData.WeaponTier higherTier = (WeaponData.WeaponTier)Mathf.Max((int)tier1, (int)tier2);
    
    // 如果两个等级相同且不是最高等级，有小概率提升一级
    if (tier1 == tier2 && (int)higherTier < 4) // 4是Legendary的值
    {
        if (UnityEngine.Random.value < 0.3f) // 30%概率提升
        {
            higherTier = (WeaponData.WeaponTier)((int)higherTier + 1);
        }
    }
    
    return higherTier;
}

/// <summary>
/// 获取商店可用物品
/// </summary>
public static List<ShopItem> GetShopInventory()
{
    List<ShopItem> shopInventory = new List<ShopItem>();
    
    // 生成商店物品（示例）
    // 基础武器
    WeaponData basicSword = new WeaponData
    {
        Id = 1001,
        Name = "基础剑",
        Description = "一把普通的剑",
        Type = WeaponData.WeaponType.Sword,
        Tier = WeaponData.WeaponTier.Basic,
        AttackBonus = 5f,
        Price = 100
    };
    shopInventory.Add(new ShopItem(basicSword, 100, true));
    
    WeaponData basicShield = new WeaponData
    {
        Id = 1002,
        Name = "基础盾",
        Description = "一面普通的盾",
        Type = WeaponData.WeaponType.Shield,
        Tier = WeaponData.WeaponTier.Basic,
        DefenseBonus = 8f,
        Price = 120
    };
    shopInventory.Add(new ShopItem(basicShield, 120, true));
    
    // 高级武器
    WeaponData advancedCannon = new WeaponData
    {
        Id = 2001,
        Name = "高级炮",
        Description = "威力更强的大炮",
        Type = WeaponData.WeaponType.Cannon,
        Tier = WeaponData.WeaponTier.Advanced,
        AttackBonus = 15f,
        Price = 500
    };
    shopInventory.Add(new ShopItem(advancedCannon, 500, true));
    
    // 专家级武器
    WeaponData expertLaser = new WeaponData
    {
        Id = 3001,
        Name = "专家激光",
        Description = "高能激光武器",
        Type = WeaponData.WeaponType.Laser,
        Tier = WeaponData.WeaponTier.Expert,
        AttackBonus = 30f,
        RangeBonus = 5f,
        Price = 1500
    };
    shopInventory.Add(new ShopItem(expertLaser, 1500, true));
    
    // 大师级武器
    WeaponData masterMissile = new WeaponData
    {
        Id = 4001,
        Name = "大师导弹",
        Description = "精准制导导弹系统",
        Type = WeaponData.WeaponType.Missile,
        Tier = WeaponData.WeaponTier.Master,
        AttackBonus = 50f,
        SpecialEffect = 10f,
        Price = 4000
    };
    shopInventory.Add(new ShopItem(masterMissile, 4000, true));
    
    // 传说级武器
    WeaponData legendaryCrystal = new WeaponData
    {
        Id = 5001,
        Name = "传说水晶",
        Description = "蕴含神秘力量的水晶",
        Type = WeaponData.WeaponType.Crystal,
        Tier = WeaponData.WeaponTier.Legendary,
        AttackBonus = 80f,
        DefenseBonus = 50f,
        SpecialEffect = 30f,
        Price = 10000
    };
    shopInventory.Add(new ShopItem(legendaryCrystal, 10000, true));
    
    return shopInventory;
}

/// <summary>
/// 购买商店物品
/// </summary>
public static bool PurchaseItem(WeaponData item, int price)
{
    if (item == null) return false;
    
    // 检查玩家是否有足够金币
    if (GameManager.Instance?.PlayerData.Coins < price)
    {
        Debug.Log("金币不足，无法购买此物品！");
        return false;
    }
    
    // 扣除金币
    if (GameManager.Instance?.PlayerData != null)
    {
        GameManager.Instance.PlayerData.AddCoins(-price);
    }
    
    // 添加到玩家装备库
    if (GameManager.Instance?.PlayerData.OwnedEquipment != null)
    {
        GameManager.Instance.PlayerData.OwnedEquipment.Add(item);
    }
    
    Debug.Log($"成功购买 {item.Name}！");
    return true;
}

/// <summary>
/// 更新商店库存
/// </summary>
public static void RefreshShopInventory()
{
    // 这里可以实现商店库存的动态更新逻辑
    // 例如：根据玩家进度解锁新的装备，或者定期刷新商品
    Debug.Log("商店库存已更新！");
}
```

## 4. 系统交互

### 4.1 数据流
```
PlayerData → EquipmentSystem → WeaponData
UI → EquipmentSystem → Equip/Unequip Result
FusionSystem → EquipmentSystem → Equipment Slots Info
```

### 4.2 事件流
- 玩家购买装备 → EquipmentSystem 添加到库存 → UI 更新显示
- 玩家装备武器 → EquipmentSystem 验证并应用 → UnitData 属性更新
- 装备合成 → EquipmentSystem 创建新装备 → UI 更新显示

### 4.3 依赖关系
- EquipmentSystem 依赖 PlayerData 管理装备库存
- EquipmentSystem 依赖 UnitData 进行装备操作
- UI系统依赖 EquipmentSystem 获取商店物品
- FusionSystem 与 EquipmentSystem 协同工作（融合后可装备6件装备）