# Kuku收集塔防游戏《Kuku Collector》战斗系统设计文档

## 1. 系统概述

战斗系统是《Kuku Collector》游戏的核心玩法之一，采用"前5分钟捕捉→后续防守"的独特机制。玩家在前5分钟内捕捉kuku，之后使用捕捉到的kuku和建造的防御设施抵御不断来袭的敌人，守护重要据点。系统包含捕捉阶段、防守阶段、敌人AI、kuku战斗AI等子系统。

## 2. 系统架构

### 2.1 BattleSystem (基础战斗系统)
- **职责**: 管理整体战斗逻辑，控制捕捉阶段到防守阶段的转换
- **类型**: 游戏系统
- **依赖**: PlayerData, KukuData, EnemyController, KukuCombatController

### 2.2 NuwaDefenseSystem (守护系统)
- **职责**: 管理守护据点的防御战斗
- **类型**: 游戏系统
- **依赖**: BattleSystem, PlayerData, MythicalKukuData

### 2.3 EnemyController (敌人控制器)
- **职责**: 管理敌人行为和AI
- **类型**: 实体控制器
- **依赖**: BattleSystem, NuwaDefenseSystem

### 2.4 KukuCombatController (库库战斗控制器)
- **职责**: 管理库库战斗AI
- **类型**: 实体控制器
- **依赖**: KukuData, EnemyController

## 3. BattleSystem (基础战斗系统)

### 3.1 类定义
```csharp
public class BattleSystem : MonoBehaviour
```

### 3.2 系统职责
- 管理"捕捉→防守"两阶段战斗逻辑
- 控制捕捉阶段倒计时和转换
- 管理防守阶段敌人生成和波次
- 协调玩家KuKu的战斗行为
- 处理战斗胜负判定
- 管理战斗状态转换

### 3.3 数据结构

#### 3.3.1 BattleState (战斗状态)
```csharp
public enum BattleState 
{ 
    Setup,                    // 设置阶段
    CapturePhase,             // 捕捉阶段（前5分钟）
    DefensePhaseSetup,        // 防守阶段设置
    WaveStart,                // 波次开始
    Fighting,                 // 战斗中
    Victory,                  // 胜利
    Defeat                    // 失败
}
```

#### 3.3.2 战斗配置参数
```csharp
// 配置参数
public float BaseEnemySpawnInterval = 2.0f;  // 基础敌人生成间隔
public int MaxEnemiesOnField = 10;           // 最大同时在场敌人数量
public Transform[] SpawnPoints;              // 敌人出生点数组
public Transform[] TemplePoints;             // 守护点目标点数组

// 捕捉阶段配置
public float CapturePhaseDuration = 300f;    // 捕捉阶段持续时间（5分钟）

// 战斗数据
private BattleState currentState = BattleState.CapturePhase; // 当前状态
private int currentWave = 0;                 // 当前波次
private int enemiesRemaining = 0;            // 剩余敌人数量
private int playerLives = 10;                // 玩家生命值（守护点血量）
private float timeUntilNextWave = 0;         // 下一波倒计时
private float capturePhaseTimer = 300f;      // 捕捉阶段倒计时
private List<GameObject> activeEnemies = new List<GameObject>(); // 活跃敌人列表
private List<GameObject> activeKukus = new List<GameObject>();    // 活跃库库列表
private List<GameObject> activeUnits = new List<GameObject>();   // 活跃单位列表（机器人/坦克）
```

#### 3.3.3 事件系统
```csharp
public event Action<int, int> OnWaveChanged;      // 波次变化事件 (当前波次, 剩余敌人)
public event Action<int> OnPlayerLifeChanged;     // 玩家生命值变化事件 (剩余生命)
public event Action OnBattleVictory;              // 战斗胜利事件
public event Action OnBattleDefeat;               // 战斗失败事件
public event Action OnCapturePhaseEnded;          // 捕捉阶段结束事件
public event Action OnDefensePhaseStarted;        // 防守阶段开始事件
public event Action<float> OnBattleUpdate;        // 战斗更新事件 (游戏时间)
```

### 3.4 核心方法

#### 3.4.1 初始化方法
```csharp
/// <summary>
/// 初始化战斗系统
/// </summary>
private void InitializeBattle()
{
    // 重置战斗数据
    currentState = BattleState.CapturePhase;
    currentWave = 0;
    playerLives = 10;
    enemiesRemaining = 0;
    timeUntilNextWave = 0;
    capturePhaseTimer = CapturePhaseDuration;
    
    // 清理之前的对象
    ClearAllObjects();
    
    Debug.Log("战斗初始化完成，进入捕捉阶段");
}
```

#### 3.4.2 战斗控制方法
```csharp
/// <summary>
/// 开始战斗
/// </summary>
public void StartBattle()
{
    try
    {
        InitializeBattle();
        StartCapturePhase();
    }
    catch (Exception e)
    {
        Debug.LogError($"开始战斗时发生错误: {e.Message}");
    }
}

/// <summary>
/// 开始捕捉阶段
/// </summary>
private void StartCapturePhase()
{
    currentState = BattleState.CapturePhase;
    capturePhaseTimer = CapturePhaseDuration;
    
    Debug.Log("捕捉阶段开始！在5分钟内尽可能多地捕捉野怪，为防守阶段做准备！");
    
    // 通知UI更新
    OnBattleUpdate?.Invoke(Time.time);
}

/// <summary>
/// 结束捕捉阶段，开始防守阶段
/// </summary>
private void StartDefensePhase()
{
    currentState = BattleState.DefensePhaseSetup;
    
    Debug.Log("捕捉阶段结束，进入防守阶段！使用捕捉到的kukus和建筑抵御敌人！");
    
    // 生成玩家kukus
    SpawnPlayerKukus();
    
    // 开始第一波敌人
    StartNextWave();
    
    // 通知UI更新
    OnDefensePhaseStarted?.Invoke();
}
```

#### 3.4.3 kuku管理方法
```csharp
/// <summary>
/// 生成玩家kuku（防守阶段）
/// </summary>
private void SpawnPlayerKukus()
{
    try
    {
        var activeKukuIds = GameManager.Instance.PlayerData.ActiveKukuTeam;
        
        for (int i = 0; i < activeKukuIds.Count && i < 5; i++) // 最多5只kuku
        {
            int kukuId = activeKukuIds[i];
            
            if (GameManager.Instance.PlayerData.CollectedKukus.ContainsKey(kukuId))
            {
                var kukuData = GameManager.Instance.PlayerData.CollectedKukus[kukuId];
                
                // 实例化kuku预制体
                GameObject kukuObject = new GameObject($"Guardian_{kukuData.Name}_{kukuId}");
                kukuObject.transform.position = new Vector3(-5 + i * 2, 0, 0); // 在守护点前方布阵
                
                // 添加kuku战斗组件
                var kukuComponent = kukuObject.AddComponent<KukuCombatController>();
                kukuComponent.Initialize(kukuData);
                
                activeKukus.Add(kukuObject);
            }
        }
        
        Debug.Log($"生成了 {activeKukus.Count} 只守护kuku来保卫守护点");
    }
    catch (Exception e)
    {
        Debug.LogError($"生成守护kuku时发生错误: {e.Message}");
    }
}
```

#### 3.4.4 敌人管理方法
```csharp
/// <summary>
/// 生成敌人
/// </summary>
private void SpawnEnemy(EnemyType type = EnemyType.WildKuku)
{
    try
    {
        if (SpawnPoints.Length == 0) return;
        
        // 选择出生点
        Transform spawnPoint = SpawnPoints[UnityEngine.Random.Range(0, SpawnPoints.Length)];
        
        // 随机选择守护点目标
        Transform[] selectedTargets = TemplePoints;
        if (TemplePoints != null && TemplePoints.Length > 0)
        {
            // 随机选择一个目标点作为主要攻击目标
            int randomIndex = UnityEngine.Random.Range(0, TemplePoints.Length);
            selectedTargets = new Transform[] { TemplePoints[randomIndex] };
        }
        
        // 创建敌人对象
        GameObject enemyObject = new GameObject($"Enemy_Type{type}_Wave{currentWave}");
        enemyObject.transform.position = spawnPoint.position;
        
        // 添加敌人组件
        var enemyComponent = enemyObject.AddComponent<EnemyController>();
        
        // 根据波次和类型设置敌人属性
        float health = 50f + currentWave * 10f;
        float speed = 1f + currentWave * 0.1f;
        float damage = 5f + currentWave * 0.5f;
        
        // 根据敌人类型调整属性
        switch (type)
        {
            case EnemyType.Demon:
                health *= 1.5f;
                damage *= 1.3f;
                break;
            case EnemyType.EliteDemon:
                health *= 2.5f;
                damage *= 2.0f;
                speed *= 1.2f;
                break;
            case EnemyType.Boss:
                health *= 5.0f;
                damage *= 3.0f;
                break;
        }
        
        enemyComponent.Initialize(health, speed, damage, selectedTargets, type);
        
        activeEnemies.Add(enemyObject);
        enemiesRemaining--;
        
        Debug.Log($"生成敌人，类型: {type}，剩余 {enemiesRemaining} 只");
    }
    catch (Exception e)
    {
        Debug.LogError($"生成敌人时发生错误: {e.Message}");
    }
}

/// <summary>
/// 开始下一波
/// </summary>
public void StartNextWave()
{
    try
    {
        currentWave++;
        
        // 计算当前波次的敌人数量和类型
        int enemyCount = Mathf.Min(currentWave * 3, 30); // 每波最多30只敌人
        enemiesRemaining = enemyCount;
        
        currentState = BattleState.WaveStart;
        
        // 通知UI更新
        OnWaveChanged?.Invoke(currentWave, enemiesRemaining);
        
        Debug.Log($"第 {currentWave} 波敌人来袭，共 {enemyCount} 只敌人，守护守护点！");
        
        // 开始生成敌人
        currentState = BattleState.Fighting;
        
        // 生成不同类型的敌人
        for (int i = 0; i < enemyCount; i++)
        {
            EnemyType type = GetEnemyTypeForWave(currentWave);
            SpawnEnemy(type);
        }
    }
    catch (Exception e)
    {
        Debug.LogError($"开始新波次时发生错误: {e.Message}");
    }
}
```

#### 3.4.5 战斗逻辑方法
```csharp
/// <summary>
/// 更新战斗逻辑
/// </summary>
private void UpdateBattleLogic()
{
    switch (currentState)
    {
        case BattleState.CapturePhase:
            UpdateCapturePhase();
            break;
            
        case BattleState.Fighting:
            UpdateDefensePhase();
            break;
            
        case BattleState.Victory:
        case BattleState.Defeat:
            // 战斗结束，无需更新
            break;
    }
    
    // 检查胜利条件
    if (currentState == BattleState.Fighting && enemiesRemaining <= 0 && activeEnemies.Count <= 0)
    {
        currentState = BattleState.Victory;
        OnBattleVictory?.Invoke();
        Debug.Log("战斗胜利！");
    }
    
    // 检查失败条件
    if (playerLives <= 0)
    {
        currentState = BattleState.Defeat;
        OnBattleDefeat?.Invoke();
        Debug.Log("战斗失败！");
    }
}

/// <summary>
/// 更新捕捉阶段
/// </summary>
private void UpdateCapturePhase()
{
    capturePhaseTimer -= Time.deltaTime;
    
    if (capturePhaseTimer <= 0)
    {
        EndCapturePhase();
    }
}

/// <summary>
/// 更新防守阶段
/// </summary>
private void UpdateDefensePhase()
{
    // 检查是否需要开始下一波
    if (enemiesRemaining <= 0 && activeEnemies.Count <= 0)
    {
        StartNextWave();
    }
}
```

#### 3.4.6 事件处理方法
```csharp
/// <summary>
/// 敌人被击败
/// </summary>
public void EnemyDefeated(GameObject enemy)
{
    try
    {
        if (activeEnemies.Contains(enemy))
        {
            activeEnemies.Remove(enemy);
            
            // 给玩家奖励
            int coins = UnityEngine.Random.Range(5, 15);
            int gems = UnityEngine.Random.Range(0, 3);
            float souls = UnityEngine.Random.Range(0.5f, 2.0f);
            
            GameManager.Instance.PlayerData.AddCoins(coins);
            GameManager.Instance.PlayerData.AddGems(gems);
            GameManager.Instance.PlayerData.AddSouls(souls);
            
            Debug.Log($"敌人被击败！获得奖励：{coins}金币，{gems}神石，{souls}灵魂");
        }
    }
    catch (Exception e)
    {
        Debug.LogError($"处理敌人被击败时发生错误: {e.Message}");
    }
}

/// <summary>
/// 敌人到达终点（破坏守护点）
/// </summary>
public void EnemyReachedEnd(GameObject enemy)
{
    try
    {
        if (activeEnemies.Contains(enemy))
        {
            activeEnemies.Remove(enemy);
            playerLives--;
            
            OnPlayerLifeChanged?.Invoke(playerLives);
            
            Debug.Log($"敌人突破防线，正在破坏守护点！剩余生命: {playerLives}");
        }
    }
    catch (Exception e)
    {
        Debug.LogError($"处理敌人到达守护点时发生错误: {e.Message}");
    }
}
```

#### 3.4.7 查询方法
```csharp
/// <summary>
/// 获取当前波次信息
/// </summary>
public (int wave, int remaining, int total) GetWaveInfo()
{
    int totalEnemies = currentWave * 3;
    return (currentWave, enemiesRemaining, totalEnemies);
}

/// <summary>
/// 获取战斗状态
/// </summary>
public (BattleState state, int lives, int wave, int enemies) GetBattleStatus()
{
    return (currentState, playerLives, currentWave, enemiesRemaining);
}

/// <summary>
/// 检查是否在捕捉阶段
/// </summary>
public bool IsInCapturePhase()
{
    return currentState == BattleState.CapturePhase;
}

/// <summary>
/// 检查是否在防守阶段
/// </summary>
public bool IsInDefensePhase()
{
    return currentState == BattleState.WaveStart || 
           currentState == BattleState.Fighting ||
           currentState == BattleState.Victory ||
           currentState == BattleState.Defeat;
}

/// <summary>
/// 获取捕捉阶段剩余时间
/// </summary>
public float GetCapturePhaseTimeRemaining()
{
    return capturePhaseTimer;
}
```

### 3.5 状态管理
- **Setup**: 战斗初始化阶段，准备战斗环境
- **CapturePhase**: 捕捉阶段，前5分钟内捕捉KuKu
- **DefensePhaseSetup**: 防守阶段设置，准备防守
- **WaveStart**: 新波次开始，准备生成敌人
- **Fighting**: 战斗进行中，敌人生成和战斗
- **Victory**: 战斗胜利，奖励发放
- **Defeat**: 战斗失败，游戏结束

## 4. NuwaDefenseSystem (守护系统)

### 4.1 类定义
```csharp
public class NuwaDefenseSystem : MonoBehaviour
```

### 4.2 系统职责
- 管理守护据点的特殊战斗模式
- 控制敌人的生成和攻击逻辑
- 管理据点生命值和防御机制
- 提供更高级别的战斗挑战

### 4.3 数据结构

#### 4.3.1 配置参数
```csharp
// 守护点相关
public GameObject guardianPoint;                    // 守护点对象
public int guardianPointHealth = 1000;              // 守护点生命值
public int maxGuardianPointHealth = 1000;          // 守护点最大生命值

// 战场设置
public Transform[] enemySpawnPoints;                // 敌人生 spawn points
public Transform[] guardianPointPoints;             // 守护点目标点数组

// 难度设置
public float difficultyMultiplier = 1.0f;          // 难度倍数
```

#### 4.3.2 战斗数据
```csharp
private int waveNumber = 1;                        // 波次数
private int enemyCount = 0;                        // 敌人数量
private bool isDefending = false;                  // 是否在防守
```

#### 4.3.3 事件系统
```csharp
public event Action<int> OnWaveStarted;            // 波次开始事件
public event Action<int, int> OnEnemySpawned;      // 敌人生成事件
public event Action<int> OnGuardianPointHealthChanged; // 守护点生命值变化事件
public event Action OnDefenseSuccess;              // 防守成功事件
public event Action OnDefenseFailed;               // 防守失败事件
```

### 4.4 核心方法

#### 4.4.1 初始化方法
```csharp
/// <summary>
/// 初始化守护系统
/// </summary>
private void InitializeDefenseSystem()
{
    guardianPointHealth = maxGuardianPointHealth;
    waveNumber = 1;
    enemyCount = 0;
    isDefending = false;
    
    Debug.Log("守护点防御系统初始化完成");
}
```

#### 4.4.2 战斗控制方法
```csharp
/// <summary>
/// 开始守护
/// </summary>
public void StartDefense()
{
    try
    {
        if (isDefending)
        {
            Debug.LogWarning("正在防守中，请勿重复开始");
            return;
        }
        
        isDefending = true;
        StartWave(waveNumber);
        
        Debug.Log("开始守护！敌人即将来袭...");
    }
    catch (Exception e)
    {
        Debug.LogError($"开始守护时发生错误: {e.Message}");
    }
}

/// <summary>
/// 开始指定波次
/// </summary>
private void StartWave(int waveNum)
{
    try
    {
        waveNumber = waveNum;
        
        // 计算当前波次的敌人数量
        int enemyToSpawn = CalculateEnemyCountForWave(waveNum);
        enemyCount = enemyToSpawn;
        
        Debug.Log($"第 {waveNum} 波敌人来袭！共 {enemyToSpawn} 只敌人试图破坏守护点！");
        
        // 通知UI
        OnWaveStarted?.Invoke(waveNum);
        
        // 开始生成敌人
        StartCoroutine(SpawnEnemiesOverTime(enemyToSpawn, waveNum));
    }
    catch (Exception e)
    {
        Debug.LogError($"开始第 {waveNum} 波时发生错误: {e.Message}");
    }
}
```

#### 4.4.3 敌人生成方法
```csharp
/// <summary>
/// 计算波次敌人数量
/// </summary>
private int CalculateEnemyCountForWave(int waveNum)
{
    // 随着波次增加，敌人数量递增
    int baseCount = 5 + waveNum * 2;
    int maxCount = 50; // 最大敌人数量
    
    return Mathf.Min(baseCount, maxCount);
}

/// <summary>
/// 持续生成敌人
/// </summary>
private System.Collections.IEnumerator SpawnEnemiesOverTime(int totalEnemies, int waveNum)
{
    float spawnInterval = Mathf.Max(0.5f, 3.0f - waveNum * 0.1f); // 随着波次增加，生成间隔变短
    
    for (int i = 0; i < totalEnemies && isDefending; i++)
    {
        SpawnSingleEnemy(waveNum);
        yield return new WaitForSeconds(spawnInterval);
    }
}

/// <summary>
/// 生成单个敌人
/// </summary>
private void SpawnSingleEnemy(int waveNum)
{
    try
    {
        if (enemySpawnPoints.Length == 0) return;
        
        // 随机选择出生点
        Transform spawnPoint = enemySpawnPoints[UnityEngine.Random.Range(0, enemySpawnPoints.Length)];
        
        // 随机选择攻击目标
        Transform targetPoint = guardianPointPoints.Length > 0 ? 
            guardianPointPoints[UnityEngine.Random.Range(0, guardianPointPoints.Length)] : null;
        
        // 创建敌人对象
        GameObject enemyObject = new GameObject($"Enemy_Wave{waveNum}_{enemyCount}");
        enemyObject.transform.position = spawnPoint.position;
        
        // 添加敌人组件
        var enemyComponent = enemyObject.AddComponent<EnemyController>();
        
        // 根据波次设置敌人属性
        float health = 50f + waveNum * 15f * difficultyMultiplier;
        float speed = 1f + waveNum * 0.1f * difficultyMultiplier;
        float damage = 20f + waveNum * 5f * difficultyMultiplier;
        
        enemyComponent.Initialize(health, speed, damage, new Transform[] { targetPoint }, EnemyType.WildKuku);
        
        enemyCount--;
        
        // 通知UI
        OnEnemySpawned?.Invoke(waveNumber, enemyCount);
        
        Debug.Log($"生成敌人，距离守护点还有 {enemyCount} 只");
    }
    catch (Exception e)
    {
        Debug.LogError($"生成敌人时发生错误: {e.Message}");
    }
}
```

#### 4.4.4 战斗处理方法
```csharp
/// <summary>
/// 敌人攻击守护点
/// </summary>
public void EnemyAttackedGuardianPoint(float damage)
{
    try
    {
        guardianPointHealth -= (int)damage;
        
        // 限制生命值在合理范围内
        guardianPointHealth = Mathf.Clamp(guardianPointHealth, 0, maxGuardianPointHealth);
        
        Debug.Log($"守护点受到攻击！当前生命值: {guardianPointHealth}/{maxGuardianPointHealth}");
        
        // 通知UI
        OnGuardianPointHealthChanged?.Invoke(guardianPointHealth);
        
        // 检查是否失败
        if (guardianPointHealth <= 0)
        {
            FailDefense();
        }
    }
    catch (Exception e)
    {
        Debug.LogError($"处理敌人攻击时发生错误: {e.Message}");
    }
}

/// <summary>
/// 敌人被击败
/// </summary>
public void EnemyDefeated()
{
    Debug.Log("敌人被击败！");
}

/// <summary>
/// 完成当前波次
/// </summary>
public void CompleteWave()
{
    try
    {
        Debug.Log($"第 {waveNumber} 波成功防守！守护点安然无恙！");
        
        // 增加玩家经验和奖励
        if (GameManager.Instance != null)
        {
            GameManager.Instance.PlayerData.AddExperience(waveNumber * 50);
            GameManager.Instance.PlayerData.AddCoins(waveNumber * 10);
        }
        
        // 检查是否达到最终波次
        if (waveNumber >= 10)
        {
            SuccessDefense();
        }
        else
        {
            // 开始下一波
            waveNumber++;
            StartWave(waveNumber);
        }
    }
    catch (Exception e)
    {
        Debug.LogError($"完成波次时发生错误: {e.Message}");
    }
}
```

#### 4.4.5 结果处理方法
```csharp
/// <summary>
/// 防守成功
/// </summary>
private void SuccessDefense()
{
    isDefending = false;
    Debug.Log("恭喜！成功守护守护点！获得了守护者的祝福！");
    
    // 给予大量奖励
    if (GameManager.Instance != null)
    {
        GameManager.Instance.PlayerData.AddGems(50);
        GameManager.Instance.PlayerData.AddCoins(500);
    }
    
    OnDefenseSuccess?.Invoke();
}

/// <summary>
/// 防守失败
/// </summary>
private void FailDefense()
{
    isDefending = false;
    Debug.Log("防守失败！敌人破坏了守护点！");
    
    OnDefenseFailed?.Invoke();
}
```

## 5. EnemyController (敌人控制器)

### 5.1 类定义
```csharp
public class EnemyController : MonoBehaviour
```

### 5.2 系统职责
- 管理敌人移动行为
- 处理敌人AI逻辑
- 管理敌人状态和交互

### 5.3 数据结构
```csharp
// 敌人属性
private float health;                              // 生命值
private float speed;                               // 移动速度
private float damage;                              // 造成的伤害
private EnemyType enemyType;                       // 敌人类型

// 目标信息
private Transform[] guardianPointPoints;           // 守护点目标点数组
private Transform currentTarget;                   // 当前目标
```

### 5.4 核心方法

#### 5.4.1 初始化方法
```csharp
/// <summary>
/// 初始化敌人
/// </summary>
public void Initialize(float h, float s, float d, Transform[] targets, EnemyType type)
{
    health = h;
    speed = s;
    damage = d;
    enemyType = type;
    guardianPointPoints = targets;
    
    // 随机选择一个守护点/建筑作为攻击目标
    if (guardianPointPoints != null && guardianPointPoints.Length > 0)
    {
        currentTarget = guardianPointPoints[UnityEngine.Random.Range(0, guardianPointPoints.Length)];
    }
    
    if (currentTarget != null)
    {
        Debug.Log($"敌人生成，目标是守护点位置: {currentTarget.position}");
    }
    else
    {
        Debug.LogWarning("敌人没有设定目标点！");
    }
}
```

#### 5.4.2 移动方法
```csharp
/// <summary>
/// 移向守护点/建筑目标
/// </summary>
private void MoveTowardsGuardianPoint()
{
    if (currentTarget == null) return;
    
    // 向目标点移动
    transform.position = Vector3.MoveTowards(transform.position, currentTarget.position, speed * Time.deltaTime);
    
    // 检查是否到达目标点
    if (Vector3.Distance(transform.position, currentTarget.position) < 0.5f)
    {
        // 到达守护点，开始破坏
        AttackGuardianPoint();
    }
}
```

#### 5.4.3 战斗方法
```csharp
/// <summary>
/// 攻击守护点/建筑
/// </summary>
private void AttackGuardianPoint()
{
    Debug.Log($"敌人到达守护点位置，造成 {damage} 点破坏！");
    
    // 通知战斗系统敌人到达目标
    if (NuwaDefenseSystem.Instance != null)
    {
        NuwaDefenseSystem.Instance.EnemyAttackedGuardianPoint(damage);
    }
    else if (BattleSystem.Instance != null)
    {
        BattleSystem.Instance.EnemyReachedEnd(gameObject);
    }
    
    // 销毁敌人对象
    Destroy(gameObject);
}

/// <summary>
/// 受到伤害
/// </summary>
public void TakeDamage(float damageAmount)
{
    health -= damageAmount;
    
    if (health <= 0)
    {
        Die();
    }
}

/// <summary>
/// 死亡
/// </summary>
private void Die()
{
    // 通知相应的战斗系统
    if (NuwaDefenseSystem.Instance != null)
    {
        NuwaDefenseSystem.Instance.EnemyDefeated();
    }
    else if (BattleSystem.Instance != null)
    {
        BattleSystem.Instance.EnemyDefeated(gameObject);
    }
    
    // 掉落物品
    DropItems();
    
    Destroy(gameObject);
}

/// <summary>
/// 掉落物品
/// </summary>
private void DropItems()
{
    // 随机掉落金币、神石、灵魂等
    int coinDrop = UnityEngine.Random.Range(5, 15);
    int gemDrop = UnityEngine.Random.Range(0, 2);
    float soulDrop = UnityEngine.Random.Range(0.5f, 1.5f);
    
    // 通知玩家获得资源
    if (GameManager.Instance != null)
    {
        GameManager.Instance.PlayerData.AddCoins(coinDrop);
        GameManager.Instance.PlayerData.AddGems(gemDrop);
        GameManager.Instance.PlayerData.AddSouls(soulDrop);
    }
    
    Debug.Log($"敌人死亡，掉落：{coinDrop}金币，{gemDrop}神石，{soulDrop}灵魂");
}
```

## 6. PetCombatController (KuKu战斗控制器)

### 6.1 类定义
```csharp
public class KukuCombatController : MonoBehaviour
```

### 6.2 系统职责
- 管理kuku战斗AI
- 处理kuku攻击逻辑
- 协调kuku与敌人的交互

### 6.3 数据结构
```csharp
// kuku数据
private KukuData kukuData;                           // kuku数据引用
private float attackTimer = 0f;                    // 攻击计时器
private float attackCooldown = 1f;                // 攻击冷却时间
private List<GameObject> nearbyEnemies = new List<GameObject>(); // 附近敌人列表
```

### 6.4 核心方法

#### 6.4.1 初始化方法
```csharp
/// <summary>
/// 初始化kuku战斗控制器
/// </summary>
public void Initialize(KukuData data)
{
    kukuData = data;
    attackCooldown = 2f / kukuData.Speed; // 攻击间隔与速度相关
}
```

#### 6.4.2 战斗AI方法
```csharp
/// <summary>
/// 攻击最近的敌人
/// </summary>
private void AttackNearestEnemy()
{
    attackTimer += Time.deltaTime;
    
    if (attackTimer >= attackCooldown)
    {
        // 寻找最近的敌人
        GameObject nearestEnemy = FindNearestEnemy();
        
        if (nearestEnemy != null)
        {
            // 执行攻击
            ExecuteAttack(nearestEnemy);
            attackTimer = 0f;
        }
    }
}

/// <summary>
/// 寻找最近的敌人
/// </summary>
private GameObject FindNearestEnemy()
{
    GameObject nearest = null;
    float nearestDistance = float.MaxValue;
    
    // 遍历所有活跃敌人
    foreach (GameObject enemy in BattleSystem.Instance.GetActiveEnemies())
    {
        float distance = Vector3.Distance(transform.position, enemy.transform.position);
        if (distance < nearestDistance)
        {
            nearestDistance = distance;
            nearest = enemy;
        }
    }
    
    return nearest;
}

/// <summary>
/// 执行攻击
/// </summary>
private void ExecuteAttack(GameObject enemy)
{
    if (enemy != null)
    {
        // 对敌人造成伤害
        EnemyController enemyController = enemy.GetComponent<EnemyController>();
        if (enemyController != null)
        {
            enemyController.TakeDamage(kukuData.AttackPower);
            Debug.Log($"{kukuData.Name} 攻击了敌人，造成 {kukuData.AttackPower} 点伤害");
        }
    }
}
```

#### 6.4.3 更新方法
```csharp
void Update()
{
    if (BattleSystem.Instance.IsInDefensePhase())
    {
        AttackNearestEnemy();
    }
}
```

## 7. 系统交互

### 7.1 数据流
```
GameManager → PlayerData → BattleSystem → KukuCombatController
BattleSystem → EnemyController → NuwaDefenseSystem
EnemyController → BattleSystem → GameManager
```

### 7.2 事件流
- BattleSystem 触发 OnBattleVictory → GameManager 处理胜利逻辑
- NuwaDefenseSystem 触发 OnDefenseSuccess → GameManager 奖励玩家
- EnemyController 触发死亡事件 → BattleSystem 更新敌人计数

### 7.3 依赖关系
- BattleSystem 依赖 PlayerData 获取玩家kukus
- EnemyController 依赖战斗系统处理结果
- KukuCombatController 依赖 KukuData 获取属性